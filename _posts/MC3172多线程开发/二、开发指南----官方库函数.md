# 二、开发指南----官方库函数

## 1、GPIO

​		MC3172 提供了 4 组 GPIO 端口，每组 16 个 IO 共 64 个 IO 引脚。通过掩码模式， 可实现对特定的 IO 读写而不影响其余 IO 功能，配合 100%单周期指令集，可实现对 IO 的精确时序控制。每个引脚都可以由软件配置成输出(推挽或开漏)、 输入(带或不带上拉)或复用的外设功能端口。

### 1.1、GPIO启动函数

​		设置外设使用的时钟频率以及特权组，GPIOA_BASE_ADDR 说明这是设置 GPIOA 的外设，可以根据需要换成  GPIOB_BASE_ADDR   ,   GPIOC_BASE_ADDR 等等。

```c
INTDEV_SET_CLK_RST
    (GPIOA_BASE_ADDR (INTDEV_RUN | INTDEV_IS_GROUP0 | INTDEV_CLK_IS_CORECLK_DIV2));
```

### 1.2、GPIO输入使能

​		这里使用了 GPIO_PIN_ALL，也可以是（GPIO_PIN0  |  GPIO_PIN1)这种具体选择的管脚。

```c
GPIO_SET_INPUT_EN_VALUE
    (GPIOA_BASE_ADDR, (GPIO_PIN_ALL), GPIO_SET_ENABLE);
```

### 1.3、GPIO输出使能

```c
GPIO_SET_OUTPUT_EN_VALUE
	(GPIOA_BASE_ADDR，(GPIO_PIN_ALL),  GPIO_SET_ENABLE);
```

### 1.4、GPIO输出高低电平

```c
GPIO_SET_OUTPUT_PIN_TO_1 ( GPIOA_BASE_ADDR,(GPIO_PIN2) );
```

```c
GPIO_SET_OUTPUT_PIN_TO_0 ( GPIOA_BASE_ADDR,(GPIO_PIN2) );
```

### 1.5、GPIO输出取反

```c
GPIO_SET_OUTPUT_PIN_TO_INV ( GPIOA_BASE_ADDR,(GPIO_PIN2) );
```

### 1.6、指定管脚输出指定值

```c
GPIO_SET_OUTPUT_PIN_VALUE
(GPIOA_BASE_ADDR， (GPIO_PIN3),  0xabcd);
```

### 1.7、读取GPIO管脚值

​		经过内部触发器延迟保护，用于采样时刻信号可能会变化的信号

```c
GPIO_GET_INPUT_VALUE_SAFE (GPIOA_BASE_ADDR);
```

​		不经过内部触发器，用于采样时刻信号不会变化的信号

```c
GPIO_GET_INPUT_VALUE_FAST (GPIOA_BASE_ADDR);
```

## 2、UART

​		多达 12 组可配置通信接口，具有强大的通信能力

### 2.1、UART启动函数

```c
INTDEV_SET_CLK_RST  (  GPCOM3_BASE_ADDR,(INTDEV_RUN|INTDEV_IS_GROUP0 | INTDEV_CLK_IS_CORECLK_DIV4));
```

### 2.2、UART输入

​		设置 P2 为输入管脚（可以在 P0-P3 按需设置）

```c
GPCOM_SET_IN_PORT ( GPCOM3_BASE_ADDR, (GPCOM_RXD_IS_P2));
```

### 2.3、UART输出

​		设置 P1 为输出管脚（可以在 P0-P3 按需设置）

```c
GPCOM_SET_OUT_PORT
(GPCOM3_BASE_ADDR，(\
GPCOM_P0_OUTPUT_DISABLE | GPCOM_P1_OUTPUT_ENABLE | GPCOM_P2_OUTPUT_DISABLE | GPCOM_P3_OUTPUT_DISABLE| \ GPCOM_P0_IS_HIGH | GPCOM_P1_IS_TXD | 
GPCOM_P2_IS_HIGH | GPCOM_P3_IS_HIGH \ ));
```

### 2.4、UART模式设置

​		设置通信接口的工作模式为 UART 模式

```c
GPCOM_SET_COM_MODE ( GPCOM3_BASE_ADDR,GPCOM_UART_MODE );
```

### 2.5、工作速度

​		设置串口的工作速度，12000000 是该外设的实际时钟频率，115200 是串口速率，可按需更改

```c
GPCOM_SET_COM_SPEED ( GPCOM3_BASE_ADDR,12000000,115200 );
```

### 2.6、管脚映射GPIO

```c
GPCOM_SET_OVERRIDE_GPIO(GPCOM3_BASE_ADDR, (\ GPCOM_P2_OVERRIDE_GPIO | GPCOM_P2_INPUT_ENABLE | \ GPCOM_P1_OVERRIDE_GPIO \ ));
```

### 2.7、读取RX缓存FIFO写指针

```c
rx_data_rp = GPCOM_GET_RX_WP (GPCOM3_BASE_ADDR);
```

### 2.8、读取RX缓存FIFO写指针指向的数据

```c
rx_data=GPCOM_GET_RX_DATA ( GPCOM3_BASE_ADDR,rx_data_rp );
```

### 2.9、检查 TX 的发射缓存是否已满

```c
GPCOM_TX_FIFO_FULL ( GPCOM3_BASE_ADDR );
```

### 2.10、检查 TX 的发射缓存是否已空

```c
GPCOM_TX_FIFO_EMPTY ( GPCOM_SEL )；
```

### 2.11、把 tx_data 送入 TX 发射缓存

​		TX 的发射缓存一共有 8 层，可以一次性送 8 个字节,非常高效

```c
GPCOM_PUSH_TX_DATA ( GPCOM3_BASE_ADDR,tx_data );
```

## 3、TIMER

​		**内核自带一个定时器，以 CPU 时钟为时钟源，32位递增计数。**

​		MC3172 包含 6 个双缓冲 24 位定时器。 该定时器的行为和目前市场的主流计数器的行为不太一致，请注意。 计数器有 2 个计数规则区，每个规则区包含计数器的起点值，终点值和计数方向。当计数器完成一个规则区的计数后，自动跳转至另 1 个规则区，用户如果想更新规则，需要读取当前计数器的计数值和使用的规则区，以确保安全更新。下一代 产品将增加规则区与规则切换模式，会更加易于使用.

### 3.1、读取内核自带的计数器

```c
unsigned long  core_cnt_value; 
core_cnt_value = CORE_CNT;
```

### 3.2、启动函数

```c
INTDEV_SET_CLK_RST ( TIMER1_BASE_ADDR,(INTDEV_RUN|INTDEV_IS_GROUP0 | INTDEV_CLK_IS_CORECLK));
```

### 3.3、设置输入输出管脚

```c
TIMER_SET_OUTPUT_EN(TIMER1_BASE_ADDR,( TIMER_P0_OUTPUT_ENABLE  | TIMER_P1_OUTPUT_ENABLE |
TIMER_P2_OUTPUT_ENABLE  | TIMER_P3_OUTPUT_ ENABLE| \ TIMER_P4_OUTPUT_DISABLE | TIMER_P5_OUTPUT_DISABLE|
TIMER_P6_OUTPUT_DISABLE | TIMER_P7_OUTPUT_DISABLE));
```

### 3.4、设置捕捉器输入映射

```c
TIMER_SET_IN_PORT(TIMER1_BASE_ADDR,(
TIMER_CAPTURER0_IS_P7 | TIMER_CAPTURER1_IS_P5|
TIMER_CAPTURER2_IS_P6 | TIMER_CAPTURER3_IS_P4 ));
```

### 3.5、设置捕捉器捕捉沿与滤波

```c
TIMER_SET_CAPTURER_MODE(TIMER1_BASE_ADDR,(TIMER_CAPTURER0_FILTER_ENABLE|TIMER_CAPTURER0_RISING_EDGE|  TIMER_CAPTURER0_FALLING_EDGE |TIMER_CAPTURER1_RISING_EDGE|  TIMER_CAPTURER3_FALLING_EDGE));
```

### 3.6、比较器输出映射

```c
TIMER_SET_OUT_PORT(TIMER1_BASE_ADDR,
( TIMER_P0_IS_COMPARER0 | TIMER_P1_IS_COMPARER1 |
  TIMER_P3_IS_COMPARER2 | TIMER_P2_IS_COMPARER 3));
```

### 3.7、计数器管脚映射

```c
TIMER_SET_OVERRIDE_GPIO(TIMER1_BASE_ADDR,(TIMER_P7_OVERRIDE_GPIO|TIMER_P7_INPUT_ENABLE|
 TIMER_P7_PULL_UP| \    TIMER_P6_OVERRIDE_GPIO|TIMER_P6_INPUT_ENABLE| \  TIMER_P5_OVERRIDE_GPIO|TIMER_P5_INPUT_ENABLE| \  TIMER_P4_OVERRIDE_GPIO|TIMER_P4_INPUT_ENABLE| \  TIMER_P3_OVERRIDE_GPIO|TIMER_P3_PULL_UP| \  TIMER_P2_OVERRIDE_GPIO| \ TIMER_P1_OVERRIDE_GPIO| \  TIMER_P0_OVERRIDE_GPIO) \ );
```

### 3.8、设置比较强模式

​		TIMER_COMPARER2_FORCE0 和 TIMER_COMPARER2_FORCE1 可 以 替 换 

TIMER_COMPARER2_NOT_FORCE 达到强制输出值的目的。

```c
TIMER_SET_COMPARER_MODE(TIMER1_BASE_ADDR,(TIMER_COMPARER3_NOT_FORCE|TIMER_COMPARER2_NOT_FORCE|
 TIMER_COMPARER1_NOT_FORCE|TIM ER_COMPARER0_NOT_FORCE));
```

### 3.9、规则区 0 设置计数方向和起始值

```c
TIMER_SET_MAIN_CNT_BEGIN_VALUE0 ( TIMER1_BASE_ADDR,
TIMER_MAIN_CNT_COUNT_UP , 0x00000000);
```

### 3.10、规则区 0 设置结束值

```c
TIMER_SET_MAIN_CNT_END_VALUE0 ( TIMER1_BASE_ADDR , 0xf000);
```

### 3.11、计数器回 0，但是并没有开始计数

```c
TIMER_SET_CMD ( TIMER1_BASE_ADDR , TIMER_CMD_RESTART);
```

### 3.12、设置比较器0的行为

​		当计数器在规则区 0 时，如果计数器等于 0xf2 则输出 0：

```c
TIMER_SET_COMPARER0_VALUE0_0(TIMER1_BASE_ADDR,
TIMER_COMPARER_OUTPUT0 , 0xf2);
```

​		当计数器在规则区 0 时，如果计数器等于 0x333 则输出 1：

```c
TIMER_SET_COMPARER0_VALUE0_1(TIMER1_BASE_ADDR,
TIMER_COMPARER_OUTPUT1 , 0x333);
```

​		当计数器在规则区 1 时，如果计数器等于 0x199 则输出取反：

```c
TIMER_SET_COMPARER0_VALUE1_0(TIMER1_BASE_ADDR,
TIMER_COMPARER_INV , 0x199);
```

​		当计数器在规则区 1 时，如果计数器等于 0x777 则保持不变：

```c
TIMER_SET_COMPARER0_VALUE1_1(TIMER1_BASE_ADDR,
TIMER_COMPARER_HOLD , 0x777);
```

​		其余比较器1~3同理

```c
TIMER_SET_COMPARER1_VALUE0_0(TIMER1_BASE_ADDR,
	TIMER_COMPARER_OUTPUT0,0x1e4); 

TIMER_SET_COMPARER1_VALUE0_1(TIMER1_BASE_ADDR,
    TIMER_COMPARER_OUTPUT1,0x553); 

TIMER_SET_COMPARER1_VALUE1_0(TIMER1_BASE_ADDR,
    TIMER_COMPARER_INV,0x291); 

TIMER_SET_COMPARER1_VALUE1_1(TIMER1_BASE_ADDR,
    IMER_COMPARER_HOLD,0x327); 

TIMER_SET_COMPARER2_VALUE0_0(TIMER1_BASE_ADDR,
    TIMER_COMPARER_OUTPUT0,0x202); 

TIMER_SET_COMPARER2_VALUE0_1(TIMER1_BASE_ADDR,
    TIMER_COMPARER_INV,0x303); 

TIMER_SET_COMPARER2_VALUE1_0(TIMER1_BASE_ADDR,
    IMER_COMPARER_OUTPUT1,0x189); 

TIMER_SET_COMPARER2_VALUE1_1(TIMER1_BASE_ADDR,
    TIMER_COMPARER_HOLD,0x377); 

TIMER_SET_COMPARER3_VALUE0_0(TIMER1_BASE_ADDR,
    TIMER_COMPARER_OUTPUT0,0xf12); 

TIMER_SET_COMPARER3_VALUE0_1(TIMER1_BASE_ADDR,
    TIMER_COMPARER_OUTPUT1,0x733); 

TIMER_SET_COMPARER3_VALUE1_0(TIMER1_BASE_ADDR,
    TIMER_COMPARER_HOLD,0x569); 

TIMER_SET_COMPARER3_VALUE1_1(TIMER1_BASE_ADDR,
     TIMER_COMPARER_INV,0x227);
```

### 3.13、开始计数

```c
TIMER_SET_CMD (TIMER1_BASE_ADDR , TIMER_CMD_RUN);
```

### 3.14、获取当前捕捉器写指针

```c
TIMER_SET_CAPTURER_MODE(timer_sel,(TIMER_CAPTURER0_FILTER_ENABLE |TIMER_CAPTURER0_RISING_EDGE|
 TIMER_CAPTURER0_FALLING_EDGE | TIMER_CAPTURER1_RISING_EDGE|
 TIMER_CAPTURER3_FALLING_EDGE));
 
capturer0_data_rp=TIMER_GET_CAPTURE0_WP(TIMER1_BASE_ADDRl);
```

### 3.15、获取当前捕捉器数值

```c
capturer0_data_temp[capturer0_data_rp]=
TIMER_GET_CAPTURE0_VALUE(TIMER1_BASE_ADDR,capturer0_data_rp);
```

## 4、SPI

### 4.1、启动函数

```c
INTDEV_SET_CLK_RST(GPCOM3_BASE_ADDR,(INTDEV_RUN|INTDEV_IS_GROUP0|INTDEV_CLK_IS_CORECLK_DIV2));
```

### 4.2、设置MASTER_IN 输入管脚

```c
GPCOM_SET_IN_PORT(GPCOM3_BASE_ADDR,(GPCOM_MASTER_IN_IS_P3));
```

### 4.3、设置输出管脚（用于CS）

​			P1 为 MASTER_CLK，P2 为 MASTER_OUT，（可以在 P0-P3 按需设置）

```c
GPCOM_SET_OUT_PORT(GPCOM3_BASE_ADDR,( \ GPCOM_P0_OUTPUT_ENABLE| GPCOM_P1_OUTPUT_ENABLE|
GPCOM_P2_OUTPUT_ENABLE| GPCOM_P3_OUTPUT_DISABLE| \ GPCOM_P0_IS_HIGH      | GPCOM_P1_IS_MASTER_CLK| GPCOM_P2_IS_MASTER_OUT| GPCOM_P3_IS_HIGH ));
```

### 4.4、设置通信接口的工作模式为 SPI_MASTER 的 MODE3 模式

```c
GPCOM_SET_COM_MODE(GPCOM3_BASE_ADDR,
(GPCOM_SPI_MASTER_MODE3 | GPCOM_TX_MSB_FIRST|
GPCOM_RX_MSB_FIRST));
```

### 4.5、设置 SPI 的工作速度

​		24000000 是该外设的实际时钟频率，1000000 是 SPI 速率，可按需更改

```c
GPCOM_SET_COM_SPEED(GPCOM3_BASE_ADDR,24000000,1000000);
```

### 4.6、设置 SPI 管脚映射 GPIO

```c
GPCOM_SET_OVERRIDE_GPIO(GPCOM3_BASE_ADDR, ( \ GPCOM_P0_OVERRIDE_GPIO| \ GPCOM_P1_OVERRIDE_GPIO| \ GPCOM_P2_OVERRIDE_GPIO| \ GPCOM_P3_OVERRIDE_GPIO| GPCOM_P3_INPUT_ENABLE \ ));
```

### 4.7、设置 P0_IS_LOW，拉低 CS，也可通过 GPIO 等效设置

```c
GPCOM_SET_OUT_PORT(GPCOM3_BASE_ADDR,( \ GPCOM_P0_OUTPUT_ENABLE|GPCOM_P1_OUTPUT_ENABLE|
GPCOM_P2_OUTPUT_ENABLE|GPCOM_P3_OUTPUT_DISABLE| \ GPCOM_P0_IS_LOW       |GPCOM_P1_IS_MASTER_CLK| GPCOM_P2_IS_MASTER_OUT|GPCOM_P3_IS_HIGH ));
```

### 4.8、设置 P0_IS_HIGH，拉高 CS，也可通过 GPIO 等效设置。

```c
GPCOM_SET_OUT_PORT(GPCOM3_BASE_ADDR,( \ GPCOM_P0_OUTPUT_ENABLE| GPCOM_P1_OUTPUT_ENABLE|
GPCOM_P2_OUTPUT_ENABLE| GPCOM_P3_OUTPUT_DISABLE| \ GPCOM_P0_IS_HIGH      | GPCOM_P1_IS_MASTER_CLK| GPCOM_P2_IS_MASTER_OUT| GPCOM_P3_IS_HIGH ));
```



### 4.9、写缓存

​		把数据写入 TX BUFFER 的 0 到 3 号缓存,只是写入，并不启动传输。

```c
GPCOM_SEND_TX_DATA(GPCOM3_BASE_ADDR,0,0xa1); GPCOM_SEND_TX_DATA(GPCOM3_BASE_ADDR,1,0xa2); GPCOM_SEND_TX_DATA(GPCOM3_BASE_ADDR,2,0xa3); GPCOM_SEND_TX_DATA(GPCOM3_BASE_ADDR,3,0xa4);
```

### 4.10、通知已写入，启动传输

​		通知外设 TX BUFFER 的缓存已经写入，将外设 GPCOM3_TX_WP 设置为 4，启动传输

```c
GPCOM_SEND_TX_WP(GPCOM3_BASE_ADDR,0x4);
```

### 4.11、等待，发送完毕

​		于等待 GPCOM3_TX_RP 等于 GPCOM3_TX_WP，这意味着外设已经传输完毕数据。GPCOM3_TX_RP 是外设的读指针，只要外设发现他的 GPCOM3_TX_RP 不等于 GPCOM3_TX_WP，就会发送数据并自加 1，直至追上 GPCOM3_TX_WP。

```c
while(GPCOM3_TX_RP!=GPCOM3_TX_WP){};
```

### 4.12、判断RX是否有数据

​		码判断 RX 是否有数据，并把数据搬移至数组 rx_data_temp。rx_data_rp 为本地变量，GPCOM3_RX_WP 为外设的 RX  FIFO 写指针

```c
u8 rx_data_rp=0;
while(rx_data_rp!=GPCOM3_RX_WP)
{ 		     	       GPCOM_GET_RX_DATA(GPCOM3_BASE_ADDR,rx_data_rp,rx_data_temp[rx_data_rp]); 
rx_data_rp++; 
};
```

